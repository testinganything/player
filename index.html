<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple YouTube Bypass Player</title>
    <link href="https://vjs.zencdn.net/8.6.1/video-js.css" rel="stylesheet" />
    <style>
        body { font-family: Arial, sans-serif; max-width: 800px; margin: 0 auto; padding: 20px; background: #f9f9f9; }
        input { width: 300px; padding: 10px; margin-right: 10px; }
        button { padding: 10px 20px; background: #ff0000; color: white; border: none; cursor: pointer; }
        button:hover { background: #cc0000; }
        #player { width: 100%; height: 400px; margin-top: 20px; }
        #error { color: red; margin-top: 10px; }
    </style>
</head>
<body>
    <h1>Simple YouTube Age Bypass Player</h1>
    <p>Enter a YouTube video ID (e.g., dQw4w9WgXcQ):</p>
    <input type="text" id="videoId" placeholder="Video ID here" />
    <button onclick="loadVideo()">Load Video</button>
    <div id="error"></div>
    <video id="player" class="video-js vjs-default-skin" controls preload="auto" data-setup="{}">
        <p class="vjs-no-js">To view this video, enable JavaScript and consider upgrading to a web browser that supports HTML5 video.</p>
    </video>

    <script src="https://vjs.zencdn.net/8.6.1/video.min.js"></script>
    <script>
        // Function to get signature timestamp from YouTube's base.js (fallback for proxy requests)
        async function getSignatureTimestamp() {
            try {
                const response = await fetch('https://www.youtube.com/s/player/2f0b1a0f/player_ias.vflset/en_US/base.js'); // Use a recent player ID; update if needed
                const text = await response.text();
                const match = text.match(/signatureTimestamp:(\d+)/);
                return match ? parseInt(match[1]) : 17280; // Fallback default
            } catch (e) {
                console.error('Failed to get timestamp:', e);
                return 17280; // Default fallback
            }
        }

        // Function to load and play video
        async function loadVideo() {
            const videoId = document.getElementById('videoId').value.trim();
            const errorDiv = document.getElementById('error');
            const playerEl = document.getElementById('player');
            errorDiv.textContent = '';

            if (!videoId) {
                errorDiv.textContent = 'Please enter a video ID.';
                return;
            }

            try {
                // Get timestamp
                const signatureTimestamp = await getSignatureTimestamp();

                // Construct proxy URL for unlocked player response
                const proxyUrl = `https://youtube-proxy.zerody.one/getPlayer?` +
                    `videoId=${encodeURIComponent(videoId)}&` +
                    `reason=LOGIN_REQUIRED&` +
                    `clientName=WEB&` +
                    `clientVersion=2.20250921.01.00&` +  // Updated for 2025; adjust if proxy rejects
                    `signatureTimestamp=${signatureTimestamp}&` +
                    `startTimeSecs=0&` +
                    `hl=en&` +
                    `userInterfaceTheme=USER_INTERFACE_THEME_LIGHT&` +
                    `isEmbed=0&` +
                    `isConfirmed=0&` +
                    `client=js`;

                // Fetch unlocked player response
                const response = await fetch(proxyUrl);
                const data = await response.json();

                if (data.playabilityStatus?.status !== 'OK') {
                    throw new Error(data.playabilityStatus?.errorScreen?.playerErrorMessageRenderer?.subreason?.runs?.[0]?.text || 'Video not playable (may be restricted or error).');
                }

                // Extract direct video URL (prefer highest quality without signature; e.g., itag 18 for 360p MP4)
                const formats = data.streamingData?.formats || [];
                const adaptiveFormats = data.streamingData?.adaptiveFormats || [];
                const allFormats = [...formats, ...adaptiveFormats];

                let bestUrl = null;
                let bestQuality = 0;
                for (const format of allFormats) {
                    if (format.url && !format.signatureCipher && format.itag === 18) {  // itag 18: 360p MP4, often direct
                        bestUrl = format.url;
                        bestQuality = 360;
                        break;  // Use first match for simplicity
                    }
                }

                if (!bestUrl) {
                    // Fallback to any direct URL
                    for (const format of allFormats) {
                        if (format.url && !format.signatureCipher) {
                            bestUrl = format.url;
                            break;
                        }
                    }
                }

                if (!bestUrl) {
                    throw new Error('No direct stream URL found (may need signature decipher for this video).');
                }

                // Load into Video.js player
                const player = videojs('player', { fluid: true });
                player.src({ src: bestUrl, type: 'video/mp4' });
                player.ready(() => {
                    player.play();
                });

            } catch (error) {
                console.error(error);
                errorDiv.textContent = `Error: ${error.message}`;
                videojs('player').pause();  // Reset player
            }
        }

        // Optional: Load video on Enter key
        document.getElementById('videoId').addEventListener('keypress', (e) => {
            if (e.key === 'Enter') loadVideo();
        });
    </script>
</body>
</html>
